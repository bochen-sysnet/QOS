max_iterations: 100
checkpoint_interval: 20
log_level: "INFO"
log_dir: null
random_seed: 42
max_tasks_per_child: 1

# Rewrite mode: output full file each iteration (stable with OE markers)
diff_based_evolution: false
max_code_length: 30000

early_stopping_patience: null
convergence_threshold: 0.001
early_stopping_metric: "combined_score"

llm:
  api_base: "https://api.openai.com/v1"
  api_key: "${OPENAI_API_KEY}"
  # available models: gpt-5.2, gpt-5.1, gpt-5, gpt-5-nano
  primary_model: "gpt-5-mini"
  temperature: 0.7
  top_p: 0.9
  max_tokens: 4096
  timeout: 450
  retries: 3
  retry_delay: 5

prompt:
  system_message: |
    You are optimizing ONLY the function evolved_cost_search(self, q, size_to_reach, budget)
    in qos/error_mitigator/evolution_target.py.

    OUTPUT FORMAT (CRITICAL):
    - Return the full file contents of qos/error_mitigator/evolution_target.py.
    - Output code only: no explanations, no markdown fences, no extra text.

    GENERALIZATION REQUIREMENT (CRITICAL):
    - The evaluator samples random (circuit_type, num_qubits) pairs each run.
    - Qubit counts are constrained to 12â€“24 and must exist in the benchmark set.
    - Your logic must generalize across circuit families (QAOA, BV, GHZ, VQE, QSVm, etc.) and sizes.
    - Do NOT branch on q.get_name(), bench strings, or any per-benchmark constants.

    FUNCTION CONTRACT (MUST FOLLOW EXACTLY):
    - Do NOT change the function signature.
      It MUST remain: evolved_cost_search(self, q, size_to_reach, budget)
    - It MUST return EXACTLY 2 values: (size_to_reach: int, method: str) where method is "GV" or "WC".
    - If you violate signature/return arity, evaluation will fail.

    CONTEXT:
    The input q is a Qernel. It contains metadata computed elsewhere, accessible via:
      input_meta = q.get_metadata()

    Useful fields may include:
      depth, num_qubits, num_clbits, num_nonlocal_gates, num_connected_components,
      number_instructions, num_measurements, num_cnot_gates,
      program_communication, liveness, parallelism, measurement,
      entanglement_ratio, critical_depth.

    Inputs/Outputs:
      - Inputs:
          * q: the Qernel (quantum circuit container) whose metadata informs the decision.
          * size_to_reach: the current target circuit size for cutting/virtualization search.
          * budget: the cost threshold used to decide whether GV/WC is acceptable.
      - Outputs:
          * size_to_reach: the chosen target size to use for the cutting/virtualization of the target circuit.
          * method: "GV" or "WC", which determines which technique is applied at that size.
      - Cost logging and traces are handled outside this file (in qos/error_mitigator/run.py).

    IMPORTANT PRACTICAL CONSTRAINTS:
    - `budget` is only meaningful for your cost-search logic (i.e., your own GV/WC cost queries).
      Do not assume downstream will enforce budget.
    - If size_to_reach >= num_qubits, the decomposition can become a no-op.
      Use that ONLY as an explicit fallback when costs indicate everything else is too expensive.
      Prefer to clamp sizes into a meaningful range (e.g., [2, num_qubits-1]) for real action.

    EFFICIENCY / GENERALIZATION GUIDELINES (HIGH IMPACT):
    - Minimize gv/wc cost calls. Avoid long +/-1 stepping loops.
      Prefer a small number of probes + bounded search (e.g., check a few candidate sizes,
      or use a short binary/ternary-style search on a clamped interval).
    - Use cheap metadata heuristics first; only call compute_*_cost when needed.
    - Keep behavior monotone and stable: similar circuits should yield similar decisions.

    METRICS:
      - qose_depth: average depth ratio (QOSE/QOS)
      - qose_cnot: average nonlocal gate ratio (QOSE/QOS)
      - qose_overhead: average number of circuits to run ratio (QOSE/QOS)
      - avg_run_time: average runtime ratio (QOSE/QOS)
      - combined_score (maximize):
          combined_score = -(qose_depth + qose_cnot + qose_overhead + avg_run_time)
    NOTE:
      - Depth/CNOT ratios are proxies for fidelity. The goal is to improve fidelity,
        reduce circuit count (overhead), and reduce cost-search time.

    ARTIFACTS PROVIDED BY EVALUATOR (per case):
      - input_features: depth, num_qubits, num_clbits, num_nonlocal_gates,
        num_connected_components, number_instructions, num_measurements, num_cnot_gates,
        program_communication, liveness, parallelism, measurement, entanglement_ratio, critical_depth
      - qose_input_size
      - qose_depth, qos_depth, qose_cnot, qos_cnot, qose_num_circuits, qos_num_circuits,
        qose_run_sec, qos_run_sec: paired QOSE/QOS metrics
      - qose_output_size, qose_method
      - qose_gv_cost_trace, qose_wc_cost_trace
      - qose_gv_time_trace, qose_wc_time_trace
      Use artifacts to diagnose decisions.
    NOTE:
      - Artifacts may also include summaries for top/diverse programs.

    ARTIFACTS PROVIDED BY EVALUATOR (summary):
      - qose_budget: budget used for all cases
      - qose_run_sec_avg: average runtime of evolved mitigator
      - qos_run_sec_avg: average runtime of baseline QOS
      - gv_cost_calls_total: total GV cost calls
      - wc_cost_calls_total: total WC cost calls
      - qos_gv_cost_calls_total: total GV cost calls for baseline QOS
      - qos_wc_cost_calls_total: total WC cost calls for baseline QOS
      - qos_depth_avg: average absolute depth of QOS
      - qos_cnot_avg: average absolute nonlocal gate count of QOS
      - qos_overhead_avg: average absolute number of QOS circuits

    One example of an evolution:
    ```
    from qos.error_mitigator.run import compute_gv_cost, compute_wc_cost
    from qos.types.types import Qernel


    def evolved_cost_search(self, q: Qernel, size_to_reach: int, budget: int):
        metadata = q.get_metadata()
        depth = metadata.get("depth", 0)
        num_qubits = metadata.get("num_qubits", 0)
        num_clbits = metadata.get("num_clbits", 0)
        num_nonlocal_gates = metadata.get("num_nonlocal_gates", 0)
        num_connected_components = metadata.get("num_connected_components", 0)
        number_instructions = metadata.get("number_instructions", 0)
        num_measurements = metadata.get("num_measurements", 0)
        num_cnot_gates = metadata.get("num_cnot_gates", 0)
        program_communication = metadata.get("program_communication", 0.0)
        liveness = metadata.get("liveness", 0.0)
        parallelism = metadata.get("parallelism", 0.0)
        measurement = metadata.get("measurement", 0.0)
        entanglement_ratio = metadata.get("entanglement_ratio", 0.0)
        critical_depth = metadata.get("critical_depth", 0.0)

        # OE_BEGIN
        # ---- Robust bounds ----
        try:
            budget_i = int(budget)
        except Exception:
            budget_i = budget

        try:
            s_in = int(size_to_reach)
        except Exception:
            s_in = 2

        try:
            nq = int(num_qubits) if num_qubits is not None else 0
        except Exception:
            nq = 0
        if nq <= 0:
            nq = max(s_in, 2)

        # Lower bound: avoid pathological tiny targets for complex/entangling circuits
        lb = 2
        if nq >= 6:
            if (
                (num_nonlocal_gates >= max(8, nq // 2))
                or (entanglement_ratio >= 0.30)
                or (num_connected_components <= 2)
                or (depth >= 18)
            ):
                lb = 3

        meaningful_ub = max(2, nq - 1)
        ub = max(lb, min(s_in, meaningful_ub))
        noop_fallback = max(s_in, nq)

        # ---- Cached cost probes ----
        _cache = {}

        def _cost(method: str, s: int):
            key = (method, s)
            if key in _cache:
                return _cache[key]
            if method == "GV":
                c = compute_gv_cost(q, s)
            else:
                c = compute_wc_cost(q, s)
            _cache[key] = c
            return c

        def _both_costs(s: int):
            return _cost("GV", s), _cost("WC", s)

        def _feasible(gv_c, wc_c) -> bool:
            return (gv_c <= budget_i) or (wc_c <= budget_i)

        # ---- Search minimal size in [lb, ub] such that GV or WC is within budget ----
        gv_lb, wc_lb = _both_costs(lb)
        if _feasible(gv_lb, wc_lb):
            chosen_s = lb
            gv_cost, wc_cost = gv_lb, wc_lb
        else:
            # If even ub is not feasible, fall back to a no-op size (>= num_qubits).
            gv_ub, wc_ub = _both_costs(ub)
            if not _feasible(gv_ub, wc_ub):
                chosen_s = noop_fallback
                gv_cost, wc_cost = gv_ub, wc_ub
            else:
                # Exponential search to bracket feasibility, then binary search.
                prev = lb
                hi = lb
                while hi < ub:
                    nxt = min(ub, max(hi + 1, hi * 2))
                    gv_n, wc_n = _both_costs(nxt)
                    if _feasible(gv_n, wc_n):
                        lo = hi + 1
                        hi = nxt
                        break
                    hi = nxt
                    prev = hi

                # Binary search in the bracket [lo, hi]
                while lo < hi:
                    mid = (lo + hi) // 2
                    gv_m, wc_m = _both_costs(mid)
                    if _feasible(gv_m, wc_m):
                        hi = mid
                    else:
                        lo = mid + 1

                chosen_s = lo
                gv_cost, wc_cost = _both_costs(chosen_s)

        size_to_reach = int(chosen_s)

        # ---- Method selection: prefer feasible + lower cost; stable tie-break ----
        gv_ok = gv_cost <= budget_i
        wc_ok = wc_cost <= budget_i

        if gv_ok and wc_ok:
            if gv_cost != wc_cost:
                method = "GV" if gv_cost < wc_cost else "WC"
            else:
                # Stable tie-breaker (bias toward GV for more entangling circuits)
                method = "GV" if entanglement_ratio >= 0.5 else "WC"
        elif gv_ok:
            method = "GV"
        elif wc_ok:
            method = "WC"
        else:
            # Should only happen in fallback paths; choose the cheaper cost.
            method = "GV" if gv_cost <= wc_cost else "WC"
        # OE_END
        return size_to_reach, method
    ```

    POSSIBLE LEVERS TO EXPLORE:
      A) Decide to use WC or GV selectively instead of always using both.
      B) Explore size_to_reach efficiently instead of using two while loops iteratively.
      C) Explore early stopping rules for WC and GV.
      D) Skip certain size_to_reach values based on heuristics.

  evaluator_system_message: "You are a strict code reviewer. Do not add commentary."
  num_top_programs: 3
  num_diverse_programs: 2
  use_template_stochasticity: true

  # Make sure OpenEvolve passes artifacts back into the model prompt each iteration.
  include_artifacts: true
  max_artifact_bytes: 65536
  artifact_security_filter: true

database:
  db_path: null
  in_memory: true
  log_prompts: true

  population_size: 100
  archive_size: 20
  num_islands: 5

  migration_interval: 30
  migration_rate: 0.12

  elite_selection_ratio: 0.05
  exploration_ratio: 0.65
  exploitation_ratio: 0.30

  feature_dimensions:
    - "complexity"
    - "diversity"
  feature_bins: 12
  diversity_reference_size: 30

evaluator:
  timeout: 4800
  max_retries: 1
  cascade_evaluation: false
  parallel_evaluations: 1
  use_llm_feedback: false
  llm_feedback_weight: 0.0

evolution_trace:
  enabled: false
  format: "jsonl"
  include_code: false
  include_prompts: false
  output_path: null
  buffer_size: 10
  compress: false
