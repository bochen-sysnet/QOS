max_iterations: 100
checkpoint_interval: 5
log_level: "INFO"
log_dir: null
random_seed: 42
max_tasks_per_child: 1

# Rewrite mode: output full file each iteration (stable with OE markers)
diff_based_evolution: false
max_code_length: 30000

early_stopping_patience: null
convergence_threshold: 0.001
early_stopping_metric: "combined_score"

llm:
  api_base: "${OPENAI_API_BASE}"
  api_key: "${OPENAI_API_KEY}"
  # available gpt models: gpt-5.2, gpt-5.1, gpt-5, gpt-5-nano
  # available gemini models: gemini-2.5-flash-lite, gemini-3-flash-preview, gemini-2.5-flash
  # available qwen models: Qwen/Qwen2.5-Coder-14B-Instruct-AWQ
  primary_model: "${OPENAI_MODEL}"
  temperature: 0.7
  top_p: 0.9
  max_tokens: 4096
  timeout: 600
  retries: 3
  retry_delay: 15

prompt:
  system_message: |
    You are optimizing ONLY the function evolved_cost_search(self, q, size_to_reach, budget)
    in qos/error_mitigator/evolution_target.py.

    OUTPUT FORMAT (CRITICAL):
    - Return the full file contents of qos/error_mitigator/evolution_target.py.
    - Output code only: no explanations, no markdown fences, no extra text.

    GENERALIZATION REQUIREMENT (CRITICAL):
    - The evaluator samples random (circuit_type, num_qubits) pairs each run.
    - Qubit counts are constrained to [12,24] and must exist in the benchmark set.
    - Your logic must generalize across circuit families (QAOA, BV, GHZ, VQE, QSVm, etc.) and sizes.
    - Do NOT branch on q.get_name(), bench strings, or any per-benchmark constants.

    FUNCTION CONTRACT (MUST FOLLOW EXACTLY):
    - Do NOT change the function signature.
      It MUST remain: evolved_cost_search(self, q, size_to_reach, budget)
    - It MUST return EXACTLY 2 values: (size_to_reach: int, method: str) where method is "GV" or "WC".
    - If you violate signature/return arity, evaluation will fail.

    CONTEXT:
    The input q is a Qernel. It contains metadata computed elsewhere, accessible via:
      input_meta = q.get_metadata()

    Useful fields may include:
      depth, num_qubits, num_clbits, num_nonlocal_gates, num_connected_components,
      number_instructions, num_measurements, num_cnot_gates,
      program_communication, liveness, parallelism, measurement,
      entanglement_ratio, critical_depth.

    COST HELPER APIS (from qos/error_mitigator/run.py):
      - compute_gv_cost(q, size_to_reach, timeout_sec=0)
      - compute_wc_cost(q, size_to_reach, timeout_sec=0)
      - Each call returns (cost: int, timed_out: bool).
      - timeout_sec is per-call; GV/WC can use different values.
      - timeout_sec=0 means no per-call timeout.
      - On timeout, cost is set high and timed_out=True.

    Inputs/Outputs:
      - Inputs:
          * q: the Qernel (quantum circuit container) whose metadata informs the decision.
          * size_to_reach: the current target circuit size for cutting/virtualization search.
          * budget: the cost threshold used to decide whether GV/WC is acceptable.
      - Outputs:
          * size_to_reach: the chosen target size to use for the cutting/virtualization of the target circuit.
          * method: "GV" or "WC", which determines which technique is applied at that size.
      - Cost logging and traces are handled outside this file (in qos/error_mitigator/run.py).

    IMPORTANT PRACTICAL CONSTRAINTS:
    - `budget` is only meaningful for your cost-search logic (i.e., your own GV/WC cost queries).
      Do not assume downstream will enforce budget.
    - If size_to_reach >= num_qubits, the decomposition can become a no-op.
      Use that ONLY as an explicit fallback when costs indicate everything else is too expensive.
      Prefer to clamp sizes into a meaningful range (e.g., [2, num_qubits-1]) for real action.

    EFFICIENCY / GENERALIZATION GUIDELINES (HIGH IMPACT):
    - Minimize gv/wc cost calls. Avoid long +/-1 stepping loops.
      Prefer a small number of probes + bounded search (e.g., check a few candidate sizes,
      or use a short binary/ternary-style search on a clamped interval).
    - Use cheap metadata heuristics first; only call compute_*_cost when needed.
    - Keep behavior monotone and stable: similar circuits should yield similar decisions.

    NOTE: "QOS" refers to the baseline implementation, and "QOSE" refers to the evolved program.

    METRICS:
      - qose_depth: average depth ratio (QOSE/QOS)
      - qose_cnot: average nonlocal gate ratio (QOSE/QOS)
      - qose_overhead: average circuit-count ratio (QOSE/QOS)
      - avg_run_time: average runtime ratio (QOSE/QOS)
      - combined_score (maximize): evaluator score used by evolution ranking.
        It uses global full-eval score on warmup/periodic refit points,
        and otherwise uses the sampled raw score.
        Sampled circuits are selected by strategy:
        correlation-based or worst-performance-based (from historical full-eval cases).
    NOTE:
      - Depth/CNOT ratios are proxies for fidelity. The goal is to improve fidelity,
        reduce cost-search time, and avoid depth/CNOT regressions.

    We provide the execution outputs of the last program executed by the evaluator. 
    Use them to diagnose decisions. Details of the execution outputs are as follows:

    EXECUTION OUTPUTS PROVIDED BY EVALUATOR:
      - Artifacts are organized as:
        * artifacts["summary"]: aggregate/run-level metrics
        * artifacts["cases"]: list of per-(bench,size) case metrics

    EXECUTION OUTPUTS PROVIDED BY EVALUATOR (artifacts["summary"]):
      - qose_budget: budget used for all cases
      - qose_run_sec_avg: average runtime of evolved mitigator
      - qos_run_sec_avg: average runtime of baseline QOS
      - gv_cost_calls_total: total GV cost calls (evolved)
      - wc_cost_calls_total: total WC cost calls (evolved)
      - qos_gv_cost_calls_total: total GV cost calls (baseline)
      - qos_wc_cost_calls_total: total WC cost calls (baseline)
      - qos_depth_avg: average absolute depth of baseline circuits
      - qos_cnot_avg: average absolute nonlocal gate count of baseline circuits

    EXECUTION OUTPUTS PROVIDED BY EVALUATOR (artifacts["cases"] per case):
      - input_features: static circuit features (depth, qubits, gates, etc.)
        num_connected_components, number_instructions, num_measurements, num_cnot_gates,
        program_communication, liveness, parallelism, measurement, entanglement_ratio, critical_depth
      - qose_input_size: initial target size before cost-search adjustments
      - qose_depth, qos_depth, qose_cnot, qos_cnot,
        qose_run_sec, qos_run_sec: paired QOSE vs baseline QOS metrics
      - qose_output_size: final target size chosen by the algorithm
      - qose_method: chosen method ("GV" or "WC")
      - qose_gv_cost_trace, qose_wc_cost_trace: cost estimates per probe step
      - qose_gv_time_trace, qose_wc_time_trace: time per probe step

    POSSIBLE LEVERS TO EXPLORE:
      A) Decide to use WC or GV selectively instead of always using both.
      B) Explore size_to_reach efficiently instead of using two while loops iteratively.
      C) Explore early stopping rules for WC and GV.
      D) Skip certain size_to_reach values based on heuristics.
      
  evaluator_system_message: "You are a strict code reviewer. Do not add commentary."
  num_top_programs: 3
  num_diverse_programs: 2
  use_template_stochasticity: true

  # Keep artifact injection enabled by default.
  include_artifacts: true
  max_artifact_bytes: 65536
  artifact_security_filter: true

database:
  db_path: null
  in_memory: true
  log_prompts: true

  population_size: 100
  archive_size: 20
  num_islands: 4

  migration_interval: 30
  migration_rate: 0.12

  elite_selection_ratio: 0.05
  exploration_ratio: 0.65
  exploitation_ratio: 0.30

  feature_dimensions:
    - "complexity"
    - "diversity"
  feature_bins: 12
  diversity_reference_size: 30

evaluator:
  timeout: 12000
  max_retries: 1
  cascade_evaluation: false
  parallel_evaluations: 1
  use_llm_feedback: false
  llm_feedback_weight: 0.0

evolution_trace:
  enabled: false
  format: "jsonl"
  include_code: false
  include_prompts: false
  output_path: null
  buffer_size: 10
  compress: false
