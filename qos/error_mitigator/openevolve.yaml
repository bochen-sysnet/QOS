max_iterations: 500
checkpoint_interval: 10
log_level: "INFO"
log_dir: null
random_seed: 42

# Rewrite mode: output full file each iteration (stable with OE markers)
diff_based_evolution: false
max_code_length: 30000

early_stopping_patience: null
convergence_threshold: 0.001
early_stopping_metric: "combined_score"

llm:
  api_base: "http://localhost:8000/v1"
  primary_model: "Qwen/Qwen2.5-Coder-14B-Instruct-AWQ"
  temperature: 0.75
  top_p: 0.92
  max_tokens: 1800
  timeout: 450
  retries: 3
  retry_delay: 1

prompt:
  system_message: |
    You are OpenEvolve. You are optimizing ONLY the function evolved_cost_search(self, q, size_to_reach, budget).

    CRITICAL OUTPUT REQUIREMENT:
      - Always output the ENTIRE FILE (all imports + full evolved_cost_search definition), not just the OE region.
      - HOWEVER, you MUST ONLY MODIFY code between markers '# OE_BEGIN' and '# OE_END'.
      - Do not change imports, module-level code, class/function signatures, or anything outside markers.

    TASK CONTEXT:
      - Each Qernel has unique metadata properties from q.get_metadata(); use them to decide how to apply
        GVOptimalDecompositionPass or OptimalWireCuttingPass and to adjust size_to_reach. They are extracted in the target code.
        Available keys (from BasicAnalysisPass and SupermarqFeaturesAnalysisPass) include:
          * depth, num_qubits, num_clbits, num_nonlocal_gates, num_connected_components,
            number_instructions, num_measurements, num_cnot_gates
          * program_communication, liveness, parallelism, measurement, entanglement_ratio, critical_depth
      - Heuristics include but are not limited to:
          * Prefer GV or larger size_to_reach when num_qubits is high or nonlocal density is low.
          * Favor GV when liveness > program_communication or entanglement_ratio is low.

    METRICS:
      - qose_depth: average depth ratio (QOSE/QOS)
      - qose_cnot: average nonlocal gate ratio (QOSE/QOS)
      - qose_overhead: average circuit-count ratio (QOSE/QOS)
      - avg_run_time: average runtime ratio (QOSE/QOS)
      - combined_score (maximize):
          combined_score = -(qose_depth + qose_cnot + qose_overhead * 10.0 + avg_run_time * 0.2)

    IMPORTANT:
      - budget is the constraint for baseline QOS and is NOT necessarily a hard constraint for evolved_cost_search.
        You may treat it only as a soft heuristic.

    ARTIFACTS PROVIDED BY EVALUATOR (per case):
      - input_features: depth, num_qubits, num_clbits, num_nonlocal_gates,
        num_connected_components, number_instructions, num_measurements, num_cnot_gates,
        program_communication, liveness, parallelism, measurement, entanglement_ratio, critical_depth
      - qose_depth, qos_depth, qose_cnot, qos_cnot, qose_num_circuits, qos_num_circuits,
        qose_run_sec, qos_run_sec: paired QOSE/QOS metrics
      - cost_search_calls: number of cost_search invocations for the case
      - gv_cost_calls: number of GV cost calls for the case
      - wc_cost_calls: number of WC cost calls for the case
      Use artifacts to diagnose regressions and avoid repeated computeCuttingCosts loops.

    ARTIFACTS PROVIDED BY EVALUATOR (summary):
      - qose_run_sec_avg: average runtime of evolved mitigator
      - qos_run_sec_avg: average runtime of baseline QOS
      - gv_cost_calls_total: total GV cost calls
      - wc_cost_calls_total: total WC cost calls
      - qos_depth_avg: average absolute depth of QOS
      - qos_cnot_avg: average absolute nonlocal gate count of QOS
      - qos_overhead_avg: average absolute number of QOS circuits

    AN EXAMPLE OF EVOLVEMENT without cost search (Not Optimal):
    def evolved_cost_search(self, q: Qernel, size_to_reach: int, budget: int):
      metadata = q.get_metadata()
      pc = metadata["program_communication"]
      liveness = metadata['liveness']
      if liveness > pc:
          return size_to_reach, "WC", 0.0
      else:
          return size_to_reach, "GV", 0.0

    HARD CONSTRAINTS:
      - Deterministic execution (no randomness).
      - Do not introduce new imports or new module dependencies.

    IMPORTANT LEVERS TO EXPLORE (must explore across evolution):
      A) Decide to use WC or GV selectively instead of always using both.

      B) Explore size_to_reach efficiently instead of using two while loops iteratively.

      C) Explore early stopping rules for WC and GV.

  evaluator_system_message: "You are a strict code reviewer. Do not add commentary."
  num_top_programs: 2
  num_diverse_programs: 2
  use_template_stochasticity: true

  # Make sure OpenEvolve passes artifacts back into the model prompt each iteration.
  include_artifacts: true
  max_artifact_bytes: 65536
  artifact_security_filter: true

database:
  db_path: openevolve_output/db
  in_memory: false
  log_prompts: true

  population_size: 24
  archive_size: 16
  num_islands: 4

  migration_interval: 30
  migration_rate: 0.12

  elite_selection_ratio: 0.05
  exploration_ratio: 0.65
  exploitation_ratio: 0.30

  feature_dimensions:
    - "complexity"
    - "diversity"
  feature_bins: 12
  diversity_reference_size: 30

evaluator:
  timeout: 100
  max_retries: 1
  cascade_evaluation: false
  parallel_evaluations: 1
  use_llm_feedback: false
  llm_feedback_weight: 0.0

evolution_trace:
  enabled: false
  format: "jsonl"
  include_code: false
  include_prompts: false
  output_path: openevolve_output/evolution_trace.jsonl
  buffer_size: 10
  compress: false
